/**
* model/Base.java
*
* File generated from the Base uml Class
* Generated by the Acceleo UML 2.1 to Java generator module (Obeo)
* $ Date : 2/26/14 2:00:36 PM (February 26, 2014) $
*/
package agents;

// Start of user code to add imports for Base

import environment.*;

import java.awt.Point;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;

// End of user code

/**
* Description of the class Base.
*
*/

public class Base extends Agent  {
    private int bois;
    private int nourriture;
    private int pv;
    private HashSet<Unite> unites;
    private String nom;
    private Carte carte;


    // Start of user code to add fields for Base

    // End of user code


    Successeurs<Point> successorComputer = new Successeurs<Point>() {
        /**
         * Doit renvoyer les points a gauche, a droite, en haut en bas du noeud passé en paramètre
         * en supprimant la Point du noeud parent de ce noeud
         *
         * @param n le noeud dont on cherche les voisins
         * @return la liste des voisins du noeud diminué de la Point du parent
         */
        @Override
        public Collection<Point> computeSuccessor(final Noeud<Point> n) {
            final Point index = n.getIndex();
            final int x = (int)index.getX();
            final int y = (int)index.getY();

            final List<Point> resultat = new ArrayList<Point>();
            if (x > 0) {
                resultat.add(new Point(x - 1, y));
            }
            if (x < carte.getLargeur() ) {
                resultat.add(new Point(x + 1, y));
            }

            if (y > 0) {
                resultat.add(new Point(x, y - 1));
            }
            if (y < carte.getHauteur() ) {
                resultat.add(new Point(x, y + 1));
            }
            if(n.getParent() != null) {
                resultat.remove(n.getParent().getIndex());
            }
            return resultat;
        }
    };

    FabriqueNoeud<Point> fabriqueNoeud = new FabriqueNoeud<Point>() {
        @Override
        protected double computeReel(final Point parentIndex, final Point index) {
            if(parentIndex != null && parentIndex.equals(index)) {
                return 0;
            }
            Case<Point> c = carte.getCase(index);
            if(c!= null && c.estLibre() && !c.estObstacle())
                return 1;

            return Double.MAX_VALUE;
        }

        @Override
        protected double computeTheorique(final Point index, final Point goal) {
            // Distance de manhattan
            return Math.abs(index.getX()-goal.getX()) + Math.abs(index.getY()-goal.getY());
        }
    };



    /**
     * Constructor.
     */
    public Base(int bois, int nourriture, int pv, String nom, Carte c) {
        // Start of user code for constructor Base
        super(pv);
        this.bois = bois;
        this.nourriture = nourriture;
        this.nom = nom;
        this.carte = c;
        // End of user code
    }

    /**
     * Return bois.
     * @return bois
     */
    public int getBois() {
        return bois;
    }

    /**
     * Set a value to attribute bois.
     * @param bois
     */
    public void setBois(int bois) {
        this.bois = bois;
    }

    /**
     * Return nourriture.
     * @return nourriture
     */
    public int getNourriture() {
        return nourriture;
    }

    /**
     * Set a value to attribute nourriture.
     * @param nourriture
     */
    public void setNourriture(int nourriture) {
        this.nourriture = nourriture;
    }

    /**
     * Return pv.
     * @return pv
     */
    public int getPv() {
        return pv;
    }

    /**
     * Set a value to attribute pv.
     * @param pv
     */
    public void setPv(int pv) {
        this.pv = pv;
    }

    /**
     * Return unites.
     * @return unites
     */
    public HashSet<Unite> getUnites() {
        return unites;
    }

    /**
     * Set a value to attribute unites.
     * @param unites
     */
    public void setUnites(HashSet<Unite> unites) {
        this.unites = unites;
    }

    /**
     * Add a unites to the unites collection.
     * @param unites_elt Element to add.
     */
    public void addUnites(Unite unites_elt) {
        this.unites.add(unites_elt);
    }

    /**
     * Remove a unites to the unites collection.
     * @param unites_elt Element to remove
     */
    public void removeUnites(Unite unites_elt) {
        this.unites.remove(unites_elt);
    }

    /**
     * Return nom.
     * @return nom
     */
    public String getNom() {
        return nom;
    }

    /**
     * Set a value to attribute nom.
     * @param nom
     */
    public void setNom(String nom) {
        this.nom = nom;
    }


    /**
     * Description of the method creerUnite.
     *
     * @param choix
     * @param nombre
     */
    public void creerUnite(int choix, int nombre) {
        // Start of user code for method creerUnite

        // End of user code
    }

    /**
     * Description of the method deplacerUnites.
     *
     * @param listeUnites
     * @param caseLibre
     */
    public void deplacerUnites(IUniteLibre listeUnites, Case caseLibre) {
        // Start of user code for method deplacerUnites
        double k;
        // End of user code
    }

    /**
     * Description of the method incrementerRessource.
     *
     */
    public void incrementerRessource(int bois, int nourriture) {
        // Start of user code for method jouer
        this.bois += bois;
        this.nourriture += nourriture;
        // End of user code
    }

    /**
     * Description of the method jouer.
     *
     */
    public void jouer() {
        // Start of user code for method jouer

        // End of user code
    }

    /**
     * Description of the method reagir.
     */
    @Override
    public void reagir() {


        final int width = carte.getLargeur();
        final int height = carte.getHauteur();
        final AEtoile<Point> astart = new AEtoile<Point>(successorComputer, fabriqueNoeud);
        final List<Point> result = astart.compute(new Point(0,0), new Point(width-1,height-1));
        //On intégre le résultat dans la matrice de base, et on l'affiche
        String [][] matrix = new String[height][width];
        for(final Point point : result) {
            System.out.println((int) point.getX());
            System.out.println((int) point.getY());
            matrix[(int) point.getY()][(int) point.getX()] = "XXXX";
        }
        displayMatrix(matrix);
    }

    /**
     * Affiche la matrice dans la sortie standard
     *
     * @param matrix la matrice a afficher
     */
    public static void displayMatrix(final String[][] matrix) {
        final StringBuilder result = new StringBuilder();
        for (int col = 0; col < matrix[0].length; ++col) {
            result.append("___");
        }
        result.append('\n');
        for (int line = 0; line < matrix.length; ++line) {
            for (int col = 0; col < matrix[line].length; ++col) {
                result.append(' ');
                result.append(matrix[line][col]);
                result.append(' ');
            }

            result.append('\n');
        }
        for (int col = 0; col < matrix[0].length; ++col) {
            result.append("___");
        }
        System.out.println(result);
    }

    // Start of user code to add methods for Base

    // End of user code
}