/**
* model/Base.java
*
* File generated from the Base uml Class
* Generated by the Acceleo UML 2.1 to Java generator module (Obeo)
* $ Date : 2/26/14 2:00:36 PM (February 26, 2014) $
*/
package agents;

// Start of user code to add imports for Base

import data.Constantes;
import environment.*;

import java.awt.Point;

import java.util.*;

// End of user code

/**
* Description of the class Base.
*
*/

public class Base extends Agent implements IAgent, Constantes {
    private int bois;
    private int nourriture;
    private List<Unite> unites;
    private String nom;
    private Carte carte;
    private Domaine domaine;

    public Jeu getJeu() {
        return jeu;
    }

    public void setJeu(Jeu jeu) {
        this.jeu = jeu;
    }

    private Jeu jeu;


    // Start of user code to add fields for Base

    // End of user code


    Successeurs<Point> successorComputer = new Successeurs<Point>() {
        /**
         * Doit renvoyer les points a gauche, a droite, en haut en bas du noeud passé en paramètre
         * en supprimant la Point du noeud parent de ce noeud
         *
         * @param n le noeud dont on cherche les voisins
         * @return la liste des voisins du noeud diminué de la Point du parent
         */
        @Override
        public Collection<Point> computeSuccessor(final Noeud<Point> n) {
            final Point index = n.getIndex();
            final int x = (int)index.getX();
            final int y = (int)index.getY();

            final List<Point> resultat = new ArrayList<Point>();
            if (x > 0) {
                resultat.add(new Point(x - 1, y));
            }
            if (x < carte.getLargeur() ) {
                resultat.add(new Point(x + 1, y));
            }

            if (y > 0) {
                resultat.add(new Point(x, y - 1));
            }
            if (y < carte.getHauteur() ) {
                resultat.add(new Point(x, y + 1));
            }
            if(n.getParent() != null) {
                resultat.remove(n.getParent().getIndex());
            }
            return resultat;
        }
    };

    FabriqueNoeud<Point> fabriqueNoeud = new FabriqueNoeud<Point>() {
        @Override
        protected double computeReel(final Point parentIndex, final Point index) {
            if(parentIndex != null && parentIndex.equals(index)) {
                return 0;
            }
            Case<Point> c = carte.getCase(index);
            if(c!= null && c.estLibre() && !c.estObstacle())
                return 1;

            return Double.MAX_VALUE;
        }

        @Override
        protected double computeTheorique(final Point index, final Point goal) {
            // Distance de manhattan
            return Math.abs(index.getX()-goal.getX()) + Math.abs(index.getY()-goal.getY());
        }
    };



    /**
     * Constructor.
     */
    public Base(int bois, int nourriture, int pv, String nom, Carte c, Domaine dom) {
        // Start of user code for constructor Base
        super(pv);
        this.bois = bois;
        this.nourriture = nourriture;
        this.nom = nom;
        this.carte = c;
        this.unites = new ArrayList<Unite>();
        this.domaine = dom;
        this.domaine.getCaseBase().ajouterUnite(this);
        // End of user code
    }

    public Case<Point> getPositionDePop() {
        Case<Point> res = null;
        ArrayList<Case<Point>> cases = new ArrayList<Case<Point>>();
        for(Case<Point> c : domaine.getCasesUnitesLibres()) {
            if(c.estLibre()) {
                cases.add(c);
            }
        }
        int n = cases.size();
        if(n > 0) {
            int number = (int)(Math.random()*n);
            res = cases.get(number);
        }
        return res;
    }

    public Case<Point> getPositionDef() {
        Case<Point> res = null;
        ArrayList<Case<Point>> cases = new ArrayList<Case<Point>>();
        for(Case<Point> c : domaine.getCasesDefenses()) {
            if(c.estLibre()) {
                cases.add(c);
            }
        }
        int n = cases.size();
        if(n > 0) {
            int number = (int)(Math.random()*n);
            res = cases.get(number);
        }
        return res;
    }

    public void creerMele() {
        if(nourriture >= MELE_COUT) {
            Case<Point> cas = getPositionDePop();
            if(cas != null)
            {
                nourriture -= MELE_COUT;
                Attaquant at = new Attaquant(this, MELE_PV, MELE_AT, MELE_P_AT, MELE_P_V, cas, carte);
                unites.add(at);
            }
        }
    }

    public void creerArcher() {
        if(nourriture >= ARCHE_COUT) {
            Case<Point> cas = getPositionDePop();
            if(cas != null)
            {
                nourriture -= ARCHE_COUT;
                Attaquant at = new Attaquant(this, ARCHE_PV, ARCHE_AT, ARCHE_P_AT, ARCHE_P_V, cas, carte);
                unites.add(at);
            }
        }
    }

     public void creerRecolteur() {
        if(nourriture >= RECOL_COUT) {
            Case<Point> cas = getPositionDePop();
            if(cas != null)
            {
                nourriture -= RECOL_COUT;
                Recolteur at = new Recolteur(this, RECOL_PV, RECOL_AT, RECOL_P_R, 0, cas, carte, RECOL_CAP);
                unites.add(at);
            }
        }
    }

    public void creerDefenseur() {
        if(bois >= DEF_COUT) {
            Case<Point> cas = getPositionDef();
            if(cas != null)
            {
                bois -= DEF_COUT;
                Defenseur at = new Defenseur(this, DEF_PV, DEF_AT, DEF_P_AT, DEF_P_V, cas, carte);
                unites.add(at);
            }
        }
    }


    /**
     * Return unites.
     * @return unites
     */
    public List<Unite> getUnites() {
        return unites;
    }

    /**
     * Add a unites to the unites collection.
     * @param unites_elt Element to add.
     */
    public void addUnites(Unite unites_elt) {
        this.unites.add(unites_elt);
    }

    /**
     * Remove a unites to the unites collection.
     * @param unites_elt Element to remove
     */
    public void removeUnites(Unite unites_elt) {
        this.unites.remove(unites_elt);
    }

    /**
     * Return nom.
     * @return nom
     */
    public String getNom() {
        return nom;
    }



    /**
     * Description of the method creerUnite.
     *
     * @param choix
     * @param nombre
     */
    public void creerUnite(int choix, int nombre) {
        // Start of user code for method creerUnite

        // End of user code
    }

    /**
     * Description of the method deplacerUnites.
     *
     * @param listeUnites
     * @param caseLibre
     */
    public void deplacerUnites(IUniteLibre listeUnites, Case caseLibre) {
        // Start of user code for method deplacerUnites
        double k;
        // End of user code
    }

    /**
     * Description of the method incrementerRessource.
     *
     */
    public void incrementerRessource(int bois, int nourriture) {
        // Start of user code for method jouer
        this.bois += bois;
        this.nourriture += nourriture;
        // End of user code
    }

    /**
     * Description of the method jouer.
     *
     */
    public void jouer() {
        // Start of user code for method jouer
        int nbRecolteur = 0;
        for(Unite u : getUnites()) {
                String className = u.getClass().getSimpleName();
                if(className.equals("Recolteur")) {
                    nbRecolteur++;
                }
            }
        // on a toujours autant de récolteur que la moitié du nombre total de ressource (sauf cas ou pas assez de ressources)
        int temp = (int)Math.floor(carte.getCasesRessources().size()/2);
        if(nbRecolteur < temp)
            for(int i=0;i<nbRecolteur-temp-1;i++)
                creerRecolteur();

        recolter();

        // si on a assez de nourriture, on lance une attaque
        if(nourriture > 780)
        {
            for(int i=0;i<10;i++)
                creerMele();
            for(int i=0;i<4;i++)
                creerArcher();
        }
        attaquer();
        if(bois > 100)
            creerDefenseur();
        // End of user code
    }

    /**
     * Stratégie d'attaque
     *
     */
    public void attaquer() {
        ArrayList<Case<Point>> cases = jeu.getCasesBases(this);
        // Calcul de la base la plus proche
        Case<Point> cible = calculerCasePlusProche(cases);
        if(cible != null) {
            // Demander aux attaquants de se diriger vers la cible
            ArrayList<Attaquant> attaquants = new ArrayList<Attaquant>();
            for(Unite u : getUnites()) {
                String className = u.getClass().getSimpleName();
                if(className.equals("Attaquant")) {
                    attaquants.add((Attaquant) u);
                }
            }
            for(Attaquant at : attaquants) {
                if(at.getPvRestant() > 0) {
                    // Priorité par rapport à la demande de la base
                    if(at.ennemiProche()) {
                        at.reagir();
                        System.out.println("On attaque ou on suit");
                    }
                    // But final qui est d'aller attaquer la cible
                    else {
                        Case<Point> caseCible = calculerChemin(at.getCase(), cible);
                        at.seDeplacer(caseCible);
                    }
                }
            }
        }
        else {
            System.out.println("Plus de cible");
        }
    }

     /**
     * Stratégie de recolter
     *
     */
    public void recolter() {
        ArrayList<Case<Point>> cases = carte.getCasesRessources();
        // Calcul de ressource la plus proche
        Case<Point> bois = calculerCasePlusProche(cases);
        Case<Point> nourriture = calculerCasePlusProche(cases);


        if(bois != null || nourriture != null) {
            // Demander aux recolteur de lancer la procedure de recolte (leur réagir)
            ArrayList<Recolteur> recolteurs = new ArrayList<Recolteur>();
            for(Unite u : getUnites()) {
                String className = u.getClass().getSimpleName();
                if(className.equals("Recolteur")) {
                    recolteurs.add((Recolteur) u);
                }
            }
            for(Recolteur rec : recolteurs) {

                rec.reagir(bois);
                // ou nourriture faut trouver un moyen de pas les faire changer de ressource cible en cours de route.
                // soit faire 2 fct récolterBois et recolterNourriture
                // soit recolterPlusProche
                // a savoir qu'ils rentrent pas à la base tant qu'ils sont pas plein donc quand la ressource s'épuisent, le calcul de ressourcePlus proche change et l'unité va partir ailleur
            }
        }
    }




    /**
     * Description of the method reagir.
     */
    @Override
    public void reagir() {
        final int width = carte.getLargeur();
        final int height = carte.getHauteur();
        final AEtoile<Point> astart = new AEtoile<Point>(successorComputer, fabriqueNoeud);
        final List<Point> result = astart.compute(new Point(0,0), new Point(width-1,height-1));
        //On intégre le résultat dans la matrice de base, et on l'affiche
        String [][] matrix = new String[height][width];
        for(final Point point : result) {
            System.out.println((int) point.getX());
            System.out.println((int) point.getY());
            matrix[(int) point.getY()][(int) point.getX()] = "XXXX";
        }
        displayMatrix(matrix);
    }

    /**
     * Affiche la matrice dans la sortie standard
     *
     * @param matrix la matrice a afficher
     */
    public static void displayMatrix(final String[][] matrix) {
        final StringBuilder result = new StringBuilder();
        for (int col = 0; col < matrix[0].length; ++col) {
            result.append("___");
        }
        result.append('\n');
        for (int line = 0; line < matrix.length; ++line) {
            for (int col = 0; col < matrix[line].length; ++col) {
                result.append(' ');
                result.append(matrix[line][col]);
                result.append(' ');
            }

            result.append('\n');
        }
        for (int col = 0; col < matrix[0].length; ++col) {
            result.append("___");
        }
        System.out.println(result);
    }

    /**
     * Return maCase.
     * @return maCase
     */
    public Case<Point> getCase() {
        return this.domaine.getCaseBase();
    }

    /**
     * Return maCase.
     * @return maCase
     */
    public Case<Point> calculerCasePlusProche(ArrayList<Case<Point>> cases) {
        double distance = Double.MAX_VALUE;
        Case<Point> resultat = null;
        for(Case<Point> c : cases) {
            int posX = (int) this.getCase().getIndex().getX();
            int posY = (int) this.getCase().getIndex().getY();
            int cX = (int) c.getIndex().getX();
            int cY = (int) c.getIndex().getY();
            double temp = Math.abs(posX-cX) + Math.abs(posY-cY);
            if(distance > temp) {
                distance = temp;
                resultat = c;
            }
        }
        return resultat;
    }

    public void subirDegats(int pvRestant) {
        if(pvRestant <= 0) {
            pv = 0;
            jeu.removeBases(this);
            getCase().retirerUnite(this);
        }

        else
            this.pv = pvRestant;
    }

    public Base getBase() {
        return this;
    }
    public int getPvRestant() {
        return pv;
    }

    // Start of user code to add methods for Base
    /**
     * Retourne la case ou doit se deplacer une unité desirant se rendre à la case destination
     * @return res
     */
    public Case<Point> calculerChemin(Case<Point> caseUnite, Case<Point> destination) {
        Case<Point> res = caseUnite;

        final AEtoile<Point> astart = new AEtoile<Point>(successorComputer, fabriqueNoeud);
        final List<Point> result = astart.compute(caseUnite.getIndex(), destination.getIndex());
        if(result.size() > 1) {
                 res = (Case<Point>)carte.getMap().get(result.get(1));
        }
        else {
                System.out.println("Pas de déplacement possible");
            }
        return res;
    }

    // End of user code
}