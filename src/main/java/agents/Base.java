/**
* model/Base.java
*
* File generated from the Base uml Class
* Generated by the Acceleo UML 2.1 to Java generator module (Obeo)
* $ Date : 2/26/14 2:00:36 PM (February 26, 2014) $
*/
package agents;

// Start of user code to add imports for Base

import environment.*;

import java.awt.Point;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;

// End of user code

/**
* Description of the class Base.
*
*/

public class Base extends Agent implements IAgent  {
    private int bois;
    private int nourriture;
    private List<Unite> unites;
    private String nom;
    private Carte carte;
    private Case<Point> maCase;

    public Jeu getJeu() {
        return jeu;
    }

    public void setJeu(Jeu jeu) {
        this.jeu = jeu;
    }

    private Jeu jeu;


    // Start of user code to add fields for Base

    // End of user code


    Successeurs<Point> successorComputer = new Successeurs<Point>() {
        /**
         * Doit renvoyer les points a gauche, a droite, en haut en bas du noeud passé en paramètre
         * en supprimant la Point du noeud parent de ce noeud
         *
         * @param n le noeud dont on cherche les voisins
         * @return la liste des voisins du noeud diminué de la Point du parent
         */
        @Override
        public Collection<Point> computeSuccessor(final Noeud<Point> n) {
            final Point index = n.getIndex();
            final int x = (int)index.getX();
            final int y = (int)index.getY();

            final List<Point> resultat = new ArrayList<Point>();
            if (x > 0) {
                resultat.add(new Point(x - 1, y));
            }
            if (x < carte.getLargeur() ) {
                resultat.add(new Point(x + 1, y));
            }

            if (y > 0) {
                resultat.add(new Point(x, y - 1));
            }
            if (y < carte.getHauteur() ) {
                resultat.add(new Point(x, y + 1));
            }
            if(n.getParent() != null) {
                resultat.remove(n.getParent().getIndex());
            }
            return resultat;
        }
    };

    FabriqueNoeud<Point> fabriqueNoeud = new FabriqueNoeud<Point>() {
        @Override
        protected double computeReel(final Point parentIndex, final Point index) {
            if(parentIndex != null && parentIndex.equals(index)) {
                return 0;
            }
            Case<Point> c = carte.getCase(index);
            if(c!= null && c.estLibre() && !c.estObstacle())
                return 1;

            return Double.MAX_VALUE;
        }

        @Override
        protected double computeTheorique(final Point index, final Point goal) {
            // Distance de manhattan
            return Math.abs(index.getX()-goal.getX()) + Math.abs(index.getY()-goal.getY());
        }
    };



    /**
     * Constructor.
     */
    public Base(int bois, int nourriture, int pv, String nom, Carte c, Case<Point> case2) {
        // Start of user code for constructor Base
        super(pv);
        this.bois = bois;
        this.nourriture = nourriture;
        this.nom = nom;
        this.carte = c;
        this.unites = new ArrayList<Unite>();
        this.maCase = case2;
        this.maCase.ajouterUnite(this);
        // End of user code
    }

    /**
     * Return bois.
     * @return bois
     */
    public int getBois() {
        return bois;
    }

    /**
     * Set a value to attribute bois.
     * @param bois
     */
    public void setBois(int bois) {
        this.bois = bois;
    }

    /**
     * Return nourriture.
     * @return nourriture
     */
    public int getNourriture() {
        return nourriture;
    }

    /**
     * Set a value to attribute nourriture.
     * @param nourriture
     */
    public void setNourriture(int nourriture) {
        this.nourriture = nourriture;
    }

    /**
     * Return unites.
     * @return unites
     */
    public List<Unite> getUnites() {
        return unites;
    }

    /**
     * Add a unites to the unites collection.
     * @param unites_elt Element to add.
     */
    public void addUnites(Unite unites_elt) {
        this.unites.add(unites_elt);
    }

    /**
     * Remove a unites to the unites collection.
     * @param unites_elt Element to remove
     */
    public void removeUnites(Unite unites_elt) {
        this.unites.remove(unites_elt);
    }

    /**
     * Return nom.
     * @return nom
     */
    public String getNom() {
        return nom;
    }

    /**
     * Set a value to attribute nom.
     * @param nom
     */
    public void setNom(String nom) {
        this.nom = nom;
    }


    /**
     * Description of the method creerUnite.
     *
     * @param choix
     * @param nombre
     */
    public void creerUnite(int choix, int nombre) {
        // Start of user code for method creerUnite

        // End of user code
    }

    /**
     * Description of the method deplacerUnites.
     *
     * @param listeUnites
     * @param caseLibre
     */
    public void deplacerUnites(IUniteLibre listeUnites, Case caseLibre) {
        // Start of user code for method deplacerUnites
        double k;
        // End of user code
    }

    /**
     * Description of the method incrementerRessource.
     *
     */
    public void incrementerRessource(int bois, int nourriture) {
        // Start of user code for method jouer
        this.bois += bois;
        this.nourriture += nourriture;
        // End of user code
    }

    /**
     * Description of the method jouer.
     *
     */
    public void jouer() {
        // Start of user code for method jouer
        attaquer();
        // End of user code
    }

    /**
     * Stratégie d'attaque
     *
     */
    public void attaquer() {
        ArrayList<Case<Point>> cases = jeu.getCasesBases(this);
        // Calcul de la base la plus proche
        Case<Point> cible = calculerBasePlusProche(cases);
        if(cible != null) {
            // Demander aux attaquants de se diriger vers la cible
            ArrayList<Attaquant> attaquants = new ArrayList<Attaquant>();
            for(Unite u : getUnites()) {
                String className = u.getClass().getSimpleName();
                if(className.equals("Attaquant")) {
                    attaquants.add((Attaquant) u);
                }
            }
            final int width = carte.getLargeur();
            final int height = carte.getHauteur();
            int i = 0;
            for(Attaquant at : attaquants) {
                if(at.getPvRestant() > 0) {
                    if(at.reagir2()) {
                        at.reagir();
                        System.out.println("On attaque");
                    }
                    else {
                        final AEtoile<Point> astart = new AEtoile<Point>(successorComputer, fabriqueNoeud);
                        final List<Point> result = astart.compute(at.getCase().getIndex(), cible.getIndex());
                        if(result.size() > 1) {
                            Case<Point> caseCible = (Case<Point>)carte.getMap().get(result.get(1));
                            at.seDeplacer(caseCible);
                        }
                        else {
                            System.out.println("Pas de déplacement possible");
                        }
                    }
                }
            }
        }
        else {
            System.out.println("Plus de cible");
        }
    }

     /**
     * Stratégie de recolter
     *
     */
    public void recolter() {
        ArrayList<Case<Point>> cases = jeu.getCasesBases(this);
        // Calcul de ressource la plus proche


        Case<Point> bois = calculerRessourcePlusProche(cases, true);
        Case<Point> nourriture = calculerRessourcePlusProche(cases,false);


        if(bois != null || nourriture != null) {
            // Demander aux recolteur de lancer la procedure de recolte (leur réagir)
            ArrayList<Recolteur> recolteur = new ArrayList<Recolteur>();
            for(Unite u : getUnites()) {
                String className = u.getClass().getSimpleName();
                if(className.equals("Recolteur")) {
                    recolteur.add((Recolteur) u);
                }
            }
            final int width = carte.getLargeur();
            final int height = carte.getHauteur();
            int i = 0;
            for(Recolteur rec : recolteur) {
                rec.reagir(bois);
                // ou nourriture faut trouver un moyen de pas les faire changer de ressource cible en cours de route.
                // soit faire 2 fct récolterBois et recolterNourriture
                // soit recolterPlusProche
                // a savoir qu'ils rentrent pas à la base tant qu'ils sont pas plein donc quand la ressource s'épuisent, le calcul de ressourcePlus proche change et l'unité va partir ailleur
            }
        }
    }




    /**
     * Description of the method reagir.
     */
    @Override
    public void reagir() {
        final int width = carte.getLargeur();
        final int height = carte.getHauteur();
        final AEtoile<Point> astart = new AEtoile<Point>(successorComputer, fabriqueNoeud);
        final List<Point> result = astart.compute(new Point(0,0), new Point(width-1,height-1));
        //On intégre le résultat dans la matrice de base, et on l'affiche
        String [][] matrix = new String[height][width];
        for(final Point point : result) {
            System.out.println((int) point.getX());
            System.out.println((int) point.getY());
            matrix[(int) point.getY()][(int) point.getX()] = "XXXX";
        }
        displayMatrix(matrix);
    }

    /**
     * Affiche la matrice dans la sortie standard
     *
     * @param matrix la matrice a afficher
     */
    public static void displayMatrix(final String[][] matrix) {
        final StringBuilder result = new StringBuilder();
        for (int col = 0; col < matrix[0].length; ++col) {
            result.append("___");
        }
        result.append('\n');
        for (int line = 0; line < matrix.length; ++line) {
            for (int col = 0; col < matrix[line].length; ++col) {
                result.append(' ');
                result.append(matrix[line][col]);
                result.append(' ');
            }

            result.append('\n');
        }
        for (int col = 0; col < matrix[0].length; ++col) {
            result.append("___");
        }
        System.out.println(result);
    }

    /**
     * Return maCase.
     * @return maCase
     */
    public Case<Point> getCase() {
        return this.maCase;
    }

    /**
     * Return maCase.
     * @return maCase
     */
    public Case<Point> calculerBasePlusProche(ArrayList<Case<Point>> cases) {
        double distance = Double.MAX_VALUE;
        Case<Point> resultat = null;
        for(Case<Point> c : cases) {
            int posX = (int) this.maCase.getIndex().getX();
            int posY = (int) this.maCase.getIndex().getY();
            int cX = (int) c.getIndex().getX();
            int cY = (int) c.getIndex().getY();
            double temp = Math.abs(posX-cX) + Math.abs(posY-cY);
            if(distance > temp) {
                distance = temp;
                resultat = c;
            }
        }
        return resultat;
    }

    public void subirDegats(int pvRestant) {
        if(pvRestant <= 0) {
            pv = 0;
            jeu.removeBases(this);
            maCase.retirerUnite(this);
        }

        else
            this.pv = pvRestant;
    }

    public Base getBase() {
        return this;
    }
    public int getPvRestant() {
        return pv;
    }

    // Start of user code to add methods for Base
    /**
     * Retourne la case ou doit se deplacer une unité desirant se rendre à la case destination
     * @return res
     */
    public Case<Point> calculerChemin(Case<Point> destination, Case<Point> caseUnite) {
        Case<Point> res = caseUnite;

        final AEtoile<Point> astart = new AEtoile<Point>(successorComputer, fabriqueNoeud);
        final List<Point> result = astart.compute(destination.getIndex(), caseUnite.getIndex());
        if(result.size() > 1) {
                 res = (Case<Point>)carte.getMap().get(result.get(1));
        }
        else {
                System.out.println("Pas de déplacement possible");
            }
        return res;
    }

    // End of user code
}