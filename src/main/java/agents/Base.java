/**
* model/Base.java
*
* File generated from the Base uml Class
* Generated by the Acceleo UML 2.1 to Java generator module (Obeo)
* $ Date : 2/26/14 2:00:36 PM (February 26, 2014) $
*/
package agents;

// Start of user code to add imports for Base

import data.Constantes;
import environment.*;

import java.awt.Point;

import java.util.*;

// End of user code

/**
* Description of the class Base.
*
*/

public class Base extends Agent implements IAgent, Constantes {


    Successeurs<Point> successorComputer = new Successeurs<Point>() {
        /**
         * Doit renvoyer les points a gauche, a droite, en haut en bas du noeud passé en paramètre
         * en supprimant la Point du noeud parent de ce noeud
         *
         * @param n le noeud dont on cherche les voisins
         * @return la liste des voisins du noeud diminué de la Point du parent
         */
        @Override
        public Collection<Point> computeSuccessor(final Noeud<Point> n) {
            final Point index = n.getIndex();
            final int x = (int)index.getX();
            final int y = (int)index.getY();

            final List<Point> resultat = new ArrayList<Point>();
            if (x > 0) {
                resultat.add(new Point(x - 1, y));
            }
            if (x < getCarte().getLargeur() ) {
                resultat.add(new Point(x + 1, y));
            }

            if (y > 0) {
                resultat.add(new Point(x, y - 1));
            }
            if (y < getCarte().getHauteur() ) {
                resultat.add(new Point(x, y + 1));
            }
            if(n.getParent() != null) {
                resultat.remove(n.getParent().getIndex());
            }
            return resultat;
        }
    };
    FabriqueNoeud<Point> fabriqueNoeud = new FabriqueNoeud<Point>() {
        @Override
        protected double computeReel(final Point parentIndex, final Point index) {
            if(parentIndex != null && parentIndex.equals(index)) {
                return 0;
            }
            Case<Point> c = getCarte().getCase(index);
            if(c!= null && c.estLibre() && !c.estObstacle())
                return 1;

            return Double.MAX_VALUE;
        }

        @Override
        protected double computeTheorique(final Point index, final Point goal) {
            // Distance de manhattan
            return Math.abs(index.getX()-goal.getX()) + Math.abs(index.getY()-goal.getY());
        }
    };
    private int bois;
    private int nourriture;
    private List<Defenseur> defenseurs;
    private List<Recolteur> recolteurs;
    private String nom;
    private Domaine domaine;
    private Jeu jeu;
    private int strat;



    /**
     * Constructor.
     */
    public Base(int bois, int nourriture, int pv, String nom, Carte c, Domaine dom, int str) {
        // Start of user code for constructor Base
        super(pv, dom.getCaseBase(), c);
        this.bois = bois;
        this.nourriture = nourriture;
        this.nom = nom;
        this.defenseurs = new ArrayList<Defenseur>();
        this.recolteurs = new ArrayList<Recolteur>();
        this.domaine = dom;
        this.domaine.getCaseBase().ajouterUnite(this);
        this.strat = str;
        // End of user code
    }

    public int getStrat() {
        return strat;
    }

    public Jeu getJeu() {
        return jeu;
    }

    public void setJeu(Jeu jeu) {
        this.jeu = jeu;
    }

    public int getNourriture() {
        return nourriture;
    }

    public int getBois() {
        return bois;
    }

    private Case<Point> getPositionDePop() {
        Case<Point> res = null;
        ArrayList<Case<Point>> cases = new ArrayList<Case<Point>>();
        for(Case<Point> c : domaine.getCasesUnitesLibres()) {
            if(c.estLibre()) {
                cases.add(c);
            }
        }
        int n = cases.size();
        if(n > 0) {
            int number = (int)(Math.random()*n);
            res = cases.get(number);
        }
        return res;
    }

    private Case<Point> getPositionDef() {
        Case<Point> res = null;
        ArrayList<Case<Point>> cases = new ArrayList<Case<Point>>();
        for(Case<Point> c : domaine.getCasesDefenses()) {
            if(c.estLibre()) {
                cases.add(c);
            }
        }
        int n = cases.size();
        if(n > 0) {
            int number = (int)(Math.random()*n);
            res = cases.get(number);
        }
        return res;
    }

    private void creerMele() {
        if(nourriture >= MELE_COUT && defenseurs.size() < MAX_ATTAQUANTS + MAX_DEFENSEURS) {
            Case<Point> cas = getPositionDePop();
            if(cas != null)
            {
                decrementerRessource(0, MELE_COUT);
                Attaquant at = new Attaquant(this, MELE_PV, MELE_AT, MELE_P_AT, MELE_P_V, cas, getCarte());
            }
        }
    }

    private void creerArcher() {
        if(nourriture >= ARCHE_COUT && defenseurs.size() < MAX_ATTAQUANTS + MAX_DEFENSEURS) {
            Case<Point> cas = getPositionDePop();
            if(cas != null)
            {
                decrementerRessource(0, ARCHE_COUT);
                Attaquant at = new Attaquant(this, ARCHE_PV, ARCHE_AT, ARCHE_P_AT, ARCHE_P_V, cas, getCarte());
            }
        }
    }

    private void creerRecolteur() {
        if(nourriture >= RECOL_COUT && recolteurs.size() < MAX_RECOLTEURS) {
            Case<Point> cas = getPositionDePop();
            if(cas != null)
            {
                decrementerRessource(0, RECOL_COUT);
                Recolteur at = new Recolteur(this, RECOL_PV, RECOL_AT, RECOL_P_R, 0, cas, getCarte(), RECOL_CAP);
            }
        }
    }

    public void creerDefenseur() {
        if(bois >= DEF_COUT && defenseurs.size() < MAX_DEFENSEURS + MAX_ATTAQUANTS) {
            Case<Point> cas = getPositionDef();
            if(cas != null)
            {
                decrementerRessource(DEF_COUT, 0);
                Defenseur at = new Defenseur(this, DEF_PV, DEF_AT, DEF_P_AT, DEF_P_V, cas, getCarte());
            }
        }
    }

    /**
     * Return unites.
     * @return unites
     */
    public void addDefenseurs(Defenseur d) {
        this.defenseurs.add(d);
    }

    /**
     * Remove a unites to the unites collection.
     * @param d Element to remove
     */
    public void removeDefenseurs(Defenseur d) {
        this.defenseurs.remove(d);
    }

    /**
     * Return unites.
     * @return unites
     */
    public List<Defenseur> getDefenseurs() {
        return defenseurs;
    }

    /**
     * Return recolteurs.
     * @return recolteurs
     */
    public void addRecolteurs(Recolteur r) {
        this.recolteurs.add(r);
    }

    /**
     * Remove a unites to the unites collection.
     * @param r Element to remove
     */
    public void removeRecolteurs(Recolteur r) {
        this.recolteurs.remove(r);
    }

    /**
     * Return unites.
     * @return unites
     */
    public List<Recolteur> getRecolteurs() {
        return recolteurs;
    }

    /**
     * Return nom.
     * @return nom
     */
    public String getNom() {
        return nom;
    }

    /**
     * Description of the method incrementerRessource.
     *
     */
    public void incrementerRessource(int bois, int nourriture) {
        // Start of user code for method jouer
        this.bois += bois;
        this.nourriture += nourriture;
        setChanged();
        notifyObservers();
        // End of user code
    }

    /**
     * Description of the method incrementerRessource.
     *
     */
    public void decrementerRessource(int bois, int nourriture) {
        // Start of user code for method jouer
        this.bois -= bois;
        this.nourriture -= nourriture;
        setChanged();
        notifyObservers();
        // End of user code
    }

    /**
     * Description of the method jouer.
     *
     */
    public void jouer() {
        // Start of user code for method jouer
        // on a toujours autant de récolteur que la moitié du nombre total de ressource (sauf cas ou pas assez de ressources)
        //int temp = (int)Math.floor(getCarte().getCasesRessources().size()/2);
        creerRecolteur();

        recolter();

        // si on a assez de nourriture, on lance une attaque
        if(nourriture > 780)
        {
            for(int i=0;i<10;i++)
                creerMele();
            for(int i=0;i<4;i++)
                creerArcher();
        }

        creerDefenseur();
        attaquer();
    }

    public void jouer2() {
        // Start of user code for method jouer
        int nbRecolteur = recolteurs.size();
        // on a toujours autant de récolteur que la moitié du nombre total de ressource (sauf cas ou pas assez de ressources)
        //int temp = (int)Math.floor(getCarte().getCasesRessources().size()/2);
        if(nbRecolteur < MAX_RECOLTEURS)
            creerRecolteur();

        recolter();
        while(nourriture > ARCHE_COUT && defenseurs.size() < MAX_DEFENSEURS + MAX_ATTAQUANTS) {
            creerArcher();
        }
        creerDefenseur();
        attaquer();
    }

    public void jouer3() {
        // Start of user code for method jouer
        int nbRecolteur = recolteurs.size();
        // on a toujours autant de récolteur que la moitié du nombre total de ressource (sauf cas ou pas assez de ressources)
        //int temp = (int)Math.floor(getCarte().getCasesRessources().size()/2);
        if(nbRecolteur < MAX_RECOLTEURS)
            creerRecolteur();

        recolter();
        creerDefenseur();
        while(nourriture > 4*RECOL_COUT && nourriture > ARCHE_COUT && defenseurs.size() < MAX_DEFENSEURS + MAX_ATTAQUANTS) {
            creerArcher();
        }
        attaquer();
    }

    /**
     * Stratégie d'attaque
     *
     */
    private void attaquer() {
        ArrayList<Case<Point>> cases = jeu.getCasesBases(this);
        // Calcul de la base la plus proche
        Case<Point> cible = calculerCasePlusProche(cases);
        if(cible != null) {
            // Demander aux attaquants de se diriger vers la cible
            for(Defenseur d : defenseurs) {
                if(d.getPvRestant() > 0) {
                    // Priorité par rapport à la demande de la base
                    if(d.ennemiProche()) {
                        d.reagir();
                    }
                    // But final qui est d'aller attaquer la cible
                    else {
                        String className = d.getClass().getSimpleName();
                        if(className.equals("Attaquant")) {
                            Attaquant at = (Attaquant) d;
                            Case<Point> caseCible = calculerChemin(at.getCase(), cible);
                            at.seDeplacer(caseCible);
                        }
                    }
                }
            }
        }
        else {
            System.out.println("Plus de cible");
        }
    }

     /**
     * Stratégie de recolter
     *
     */
     private void recolter() {
        ArrayList<Case<Point>> cases = getCarte().getCasesRessources(TypeRessource.BOIS);
        // Calcul de ressource la plus proche
        Case<Point> bois = calculerCasePlusProche(cases);
        cases = getCarte().getCasesRessources(TypeRessource.NOURRITURE);
        Case<Point> nourriture = calculerCasePlusProche(cases);


        if(bois != null || nourriture != null) {
            if(bois == null) {
                for(Recolteur rec : recolteurs) {
                    rec.reagir(nourriture);
                }
            }
            if(nourriture == null) {
                for(Recolteur rec : recolteurs) {
                    rec.reagir(bois);
                }
            }
            if(bois != null && nourriture != null) {

            }
            // Demander aux recolteur de lancer la procedure de recolte (leur réagir)
            Iterator iter = recolteurs.iterator();
            int size = recolteurs.size();
            int i = 1;
            for(Recolteur rec : recolteurs) {
                if(i <= size/2)
                    rec.reagir(bois);
                else
                    rec.reagir(nourriture);
                i++;
            }
        }
    }

    /**
     * Stratégie de recolter
     *
     */
    private void recolter(TypeRessource type) {
        ArrayList<Case<Point>> cases = getCarte().getCasesRessources(type);
        // Calcul de ressource la plus proche
        Case<Point> casePlusProche = calculerCasePlusProche(cases);


        if(casePlusProche != null) {
            for(Recolteur rec : recolteurs) {
                rec.reagir(casePlusProche);
            }
        }
    }

    /**
     * Description of the method reagir.
     * action réactive de l'agent
     */
    @Override
    public void reagir() {
        jouer();
    }

    /**
     * Return maCase.
     * @return maCase
     */
    public Case<Point> getCase() {
        return this.domaine.getCaseBase();
    }

    /**
     * Return maCase.
     * @return maCase
     */
    private Case<Point> calculerCasePlusProche(ArrayList<Case<Point>> cases) {
        double distance = Double.MAX_VALUE;
        Case<Point> resultat = null;
        for(Case<Point> c : cases) {
            int posX = (int) this.getCase().getIndex().getX();
            int posY = (int) this.getCase().getIndex().getY();
            int cX = (int) c.getIndex().getX();
            int cY = (int) c.getIndex().getY();
            double temp = Math.abs(posX-cX) + Math.abs(posY-cY);
            if(distance > temp) {
                distance = temp;
                resultat = c;
            }
        }
        return resultat;
    }

    public void subirDegats(int degats) {
        super.subirDegats(degats);
        if(getPvRestant() == 0) {
            jeu.removeBases(this);
            for(Defenseur d : defenseurs) {
                d.getCase().retirerUnite(d);
            }
            for(Recolteur d : recolteurs) {
                d.getCase().retirerUnite(d);
            }
            defenseurs = new ArrayList<Defenseur>();
            recolteurs = new ArrayList<Recolteur>();
            getCase().retirerUnite(this);
            while(defenseurs.size() != 0) {
                defenseurs.get(0).subirDegats(100);
            }
            setChanged();
            notifyObservers();
        }
    }

    public Base getBase() {
        return this;
    }

    // Start of user code to add methods for Base

    /**
     * Retourne la case ou doit se deplacer une unité desirant se rendre à la case destination
     * @return res
     */
    public Case<Point> calculerChemin(Case<Point> caseUnite, Case<Point> destination) {
        Case<Point> res = caseUnite;

        final AEtoile<Point> astart = new AEtoile<Point>(successorComputer, fabriqueNoeud);
        final List<Point> result = astart.calculer(caseUnite.getIndex(), destination.getIndex());
        if(result.size() > 1) {
                 res = (Case<Point>)getCarte().getMap().get(result.get(1));
        }
        else {
                System.out.println("Pas de déplacement possible");
            }
        return res;
    }

    // End of user code
}